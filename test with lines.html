<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>25-26T1 Week1-2</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles to enhance Tailwind defaults and ensure responsiveness */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8f8f8;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        /* Styles for the modal backdrop */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
        }

        /* Styles for the modal content */
        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            text-align: center;
            max-width: 500px;
            width: 90%;
            animation: fadeIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Custom container for positioning the canvas */
        .quiz-columns-container {
            position: relative; /* Establish positioning context for the canvas */
        }

        /* Canvas for drawing lines */
        #lineCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            /* Important: Ensures the canvas doesn't block mouse clicks on words/definitions */
            pointer-events: none;
            z-index: 10; 
        }
    </style>
</head>
<body class="selection:bg-blue-200">
    <div id="quiz-main-container" class="bg-white p-6 md:p-10 rounded-xl shadow-lg w-full max-w-4xl space-y-6">
        <div class="text-center space-y-4">
            <h1 id="dateHeading" class="text-3xl md:text-4xl font-extrabold text-gray-800"></h1>
            <div id="timer" class="text-4xl font-bold text-blue-600">04:00</div>
            <input type="text" id="studentName" placeholder="Enter your name"
                   class="w-full md:w-1/2 p-3 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 text-center text-lg shadow-sm"
                   aria-label="Student Name">
        </div>

        <div class="quiz-columns-container flex flex-col md:flex-row justify-between gap-6">
            
            <canvas id="lineCanvas"></canvas>

            <div class="column flex-1 bg-yellow-50 p-4 rounded-lg shadow-md min-h-[300px] md:min-h-[500px] border border-yellow-200 overflow-auto" id="wordColumn">
                </div>
            <div class="column flex-1 bg-blue-50 p-4 rounded-lg shadow-md min-h-[300px] md:min-h-[500px] border border-blue-200 overflow-auto" id="definitionColumn">
                </div>
        </div>

        <div class="flex flex-col md:flex-row justify-center gap-4 mt-6">
            <button id="submitButton" onclick="submitQuiz()"
                    class="px-8 py-4 bg-gray-300 text-gray-700 font-semibold rounded-lg shadow-md transition-all duration-300 ease-in-out
                           hover:bg-green-600 hover:text-white focus:outline-none focus:ring-4 focus:ring-green-300 text-lg cursor-not-allowed"
                    disabled>
                Submit Quiz
            </button>
            <button id="resetButton" onclick="resetQuiz()"
                    class="px-8 py-4 bg-red-400 text-white font-semibold rounded-lg shadow-md transition-all duration-300 ease-in-out
                           hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300 text-lg">
                Reset Quiz
            </button>
        </div>
    </div>

    <div id="customModal" class="modal-backdrop hidden">
        <div class="modal-content">
            <h2 id="modalTitle" class="text-2xl font-bold mb-4 text-gray-800"></h2>
            <div id="modalMessage" class="text-base text-gray-700 leading-relaxed mb-6 whitespace-pre-line text-left"></div>
            <button onclick="closeModal()"
                    class="px-6 py-3 bg-blue-500 text-white font-semibold rounded-lg shadow-md transition-all duration-300 ease-in-out
                           hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-blue-300 text-lg">
                Close
            </button>
        </div>
    </div>

    <script>
        // Vocabulary data for the quiz
        const vocabulary = [
            { word: "recall", definition: "(v.) to bring back to mind; remember" },
            { word: "derive", definition: "(v.) to obtain something from (a specified source)" },
            { word: "tendency", definition: "(n.) an inclination to do something" },
            { word: "ultimate", definition: "(adj.) being or happening at the end of a process; final" },
            { word: "navigate", definition: "(v.) to find one's way through" },
            { word: "retain", definition: "(v.) to continue to have (something); keep possession of" },
            { word: "vastly", definition: "(adv.) to an exceedingly great extent or degree; immensely" },
            { word: "ambiguous", definition: "(adj.) open to more than one interpretation; having a double meaning" },
            { word: "portion", definition: "(n.) a part of a food serving intended for one person" },
            { word: "furious", definition: "(adj.) extremely angry; enraged" },
            { word: "persist", definition: "(v.) continue to exist or occur over a prolonged period" },
            { word: "cram", definition: "(v.) to prepare for a test or examination by learning a great deal of information in a very short period" },
            { word: "interleaving", definition: "(v.) to insert (something) between other things; interrupt with" },
            { word: "retention", definition: "(n.) the continued possession, control, or preservation of something" },
            { word: "counterintuitive", definition: "(adj.) contrary to what intuition would suggest" },
            { word: "deploy", definition: "(v.) To bring (resources) into effective action" },
            { word: "identify", definition: "(v.) establish or indicate who or what (someone or something) is" },
        ];

        let selectedWord = null; // Stores the currently selected word DOM element
        let matchedPairs = new Map(); // Stores matched word-definition DOM element pairs
        let startTime; // Timestamp when the quiz starts
        let timerInterval; // Interval ID for the timer
        const totalTime = 240; // Total time for the quiz in seconds (4 minutes)
        let remainingTime = totalTime; // Remaining time in seconds
        let quizActive = false; // Flag to indicate if the quiz is active

        // --- Line Drawing Variables and Setup ---
        const canvas = document.getElementById('lineCanvas');
        const ctx = canvas.getContext('2d');
        const columnsContainer = document.querySelector('.quiz-columns-container');
        
        // Tracks the single line currently being drawn (from selected word to cursor/definition)
        let lineData = null; 
        
        // Map to store coordinates for permanently matched (pink) lines
        const matchLines = new Map(); 

        // Function to initialize or reset the quiz
        function initQuiz() {
            // Clear existing elements
            document.getElementById('wordColumn').innerHTML = '';
            document.getElementById('definitionColumn').innerHTML = '';
            matchedPairs.clear();
            selectedWord = null;
            document.getElementById('submitButton').classList.remove('bg-green-500', 'hover:bg-green-600', 'text-white');
            document.getElementById('submitButton').classList.add('bg-gray-300', 'text-gray-700');
            document.getElementById('submitButton').disabled = true; // Disable submit button initially
            document.getElementById('studentName').value = ''; // Clear student name

            // Clear all line data and redraw the canvas
            matchLines.clear();
            clearLine(); 
            // Also ensure selectedWord is cleared of any highlight
            if (selectedWord) {
                selectedWord.classList.remove('bg-green-400', 'border-green-500'); 
                selectedWord.classList.add('bg-yellow-200', 'border-yellow-300');
            }


            // Set current date heading
            document.getElementById('dateHeading').textContent = '25-26T1 Week1-2';

            // Randomly select 10 words and their definitions
            const selectedWordsData = shuffleArray(vocabulary).slice(0, 10);
            const correctDefinitionsData = selectedWordsData.map(item => item.definition);

            // Randomly select 0 distractor definitions
            const extraDefinitionsData = shuffleArray(vocabulary)
                .filter(item => !correctDefinitionsData.includes(item.definition)) 
                .slice(0, 0)
                .map(item => item.definition);

            // Combine all definitions (10 correct + 0 distractors) and shuffle them
            const allDefinitions = shuffleArray([...correctDefinitionsData, ...extraDefinitionsData]);

            // Display words in the word column
            selectedWordsData.forEach(item => {
                const div = document.createElement('div');
                div.className = 'word p-3 mb-2 rounded-lg cursor-pointer transition-all duration-200 ease-in-out ' +
                                 'bg-yellow-200 hover:bg-yellow-300 shadow-sm border border-yellow-300';
                div.textContent = item.word;
                div.dataset.definition = item.definition; // Store correct definition for checking
                div.addEventListener('click', handleWordClick);
                div.addEventListener('dblclick', handleWordDoubleClick);
                document.getElementById('wordColumn').appendChild(div);
            });

            // Display definitions in the definition column
            allDefinitions.forEach(definition => {
                const div = document.createElement('div');
                div.className = 'definition p-3 mb-2 rounded-lg cursor-pointer transition-all duration-200 ease-in-out ' +
                                 'bg-blue-200 hover:bg-blue-300 shadow-sm border border-blue-300';
                div.textContent = definition;
                div.addEventListener('click', handleDefinitionClick);
                document.getElementById('definitionColumn').appendChild(div);
            });

            // Set up canvas size and start the timer
            resizeCanvas();
            startTimer();
            quizActive = true;
        }

        // Resizes the canvas to match the columns container dimensions
        function resizeCanvas() {
            const rect = columnsContainer.getBoundingClientRect();
            // Set canvas size to match the container's *client* size
            canvas.width = columnsContainer.clientWidth; 
            canvas.height = columnsContainer.clientHeight;
        }

        // Helper function to get the center-right or center-left coordinates of an element
        function getElementLinePoint(element, isWord) {
            const rect = element.getBoundingClientRect();
            const containerRect = columnsContainer.getBoundingClientRect();
            const x = isWord ? rect.right - containerRect.left : rect.left - containerRect.left;
            const y = rect.top + rect.height / 2 - containerRect.top;
            return { x, y };
        }

        // Clears the canvas entirely and resets lineData
        function clearLine() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            lineData = null; // Clear active line data
            drawMatchedLines(); // Redraw permanent lines
        }

        // Draws a single active line (from a selected word)
        function drawActiveLine(startX, startY, endX, endY) {
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.strokeStyle = '#10B981'; // Green color for active selection
            ctx.lineWidth = 3;
            ctx.stroke();
        }
        
        // Draws all the permanently matched lines (pink)
        function drawMatchedLines() {
            matchLines.forEach((coords, wordElement) => {
                // Check if the word element is still present in the DOM before drawing
                if (document.body.contains(wordElement)) {
                    ctx.beginPath();
                    ctx.moveTo(coords.startX, coords.startY);
                    ctx.lineTo(coords.endX, coords.endY);
                    ctx.strokeStyle = '#EC4899'; // Pink color for matched pair
                    ctx.lineWidth = 2;
                    ctx.stroke();
                } else {
                    // Remove entry if element is no longer there (shouldn't happen on this quiz)
                    matchLines.delete(wordElement);
                }
            });
        }
        
        // Main function to draw all lines (active and matched)
        function drawLines() {
            clearLine(); // Clears all, redraws matched
            if (lineData) {
                // Redraw active line over the matched lines
                drawActiveLine(lineData.startX, lineData.startY, lineData.endX, lineData.endY);
            }
        }
        
        // Handles mouse movement to draw the line to the cursor
        function handleMouseMove(e) {
            if (selectedWord) {
                // Get coordinates relative to the canvas/container
                const containerRect = columnsContainer.getBoundingClientRect();
                const mouseX = e.clientX - containerRect.left;
                const mouseY = e.clientY - containerRect.top;

                const wordPoint = getElementLinePoint(selectedWord, true);
                
                // Update active line data to current cursor position
                lineData = {
                    startX: wordPoint.x,
                    startY: wordPoint.y,
                    endX: mouseX,
                    endY: mouseY
                };
                drawLines(); // Redraw everything
            }
        }
        
        // Attach the mouse move listener to the columns container
        columnsContainer.addEventListener('mousemove', handleMouseMove);

        // Handles click on a word element
        function handleWordClick(e) {
            const word = e.target;
            // If already matched (pink background), do nothing
            if (word.classList.contains('bg-pink-300')) {
                clearLine(); // Still clear any active line
                return;
            }

            // Remove 'selected' class (green highlight) from previously selected word
            if (selectedWord && selectedWord !== word) {
                selectedWord.classList.remove('bg-green-400', 'border-green-500'); // Remove green highlight
                selectedWord.classList.add('bg-yellow-200', 'border-yellow-300'); // Restore yellow
            }
            
            // Toggle selection
            if (selectedWord === word) {
                selectedWord.classList.remove('bg-green-400', 'border-green-500');
                selectedWord.classList.add('bg-yellow-200', 'border-yellow-300');
                selectedWord = null;
                clearLine(); // Clear line if deselected
            } else {
                // Set new selected word and highlight it
                selectedWord = word;
                selectedWord.classList.add('bg-green-400', 'border-green-500'); // Add green highlight
                selectedWord.classList.remove('bg-yellow-200', 'border-yellow-300'); // Remove yellow
                // Initial line drawing to cursor will happen on mousemove
            }
        }

        // Handles double-click on a word element (for unmatching)
        function handleWordDoubleClick(e) {
            e.preventDefault();
            const word = e.target;

            // Clear any active line
            selectedWord = null;
            word.classList.remove('bg-green-400', 'border-green-500'); 
            word.classList.add('bg-yellow-200', 'border-yellow-300');
            clearLine(); 

            // If the word is currently matched (has pink background), unmatch it
            if (word.classList.contains('bg-pink-300')) {
                const definition = matchedPairs.get(word);
                if (definition) {
                    // Remove 'matched' styling from both word and definition
                    definition.classList.remove('bg-pink-300', 'border-pink-400', 'cursor-default');
                    definition.classList.add('bg-blue-200', 'hover:bg-blue-300', 'border-blue-300', 'cursor-pointer');
                    matchedPairs.delete(word); // Remove from matched pairs map
                    matchLines.delete(word); // Remove line data
                }
                word.classList.remove('bg-pink-300', 'border-pink-400', 'cursor-default');
                word.classList.add('bg-yellow-200', 'hover:bg-yellow-300', 'border-yellow-300', 'cursor-pointer');
            }
            drawLines(); // Redraw to remove unmatch line
            checkCompletion();
        }

        // Handles click on a definition element
        function handleDefinitionClick(e) {
            const definition = e.target;
            // If already matched (pink background), do nothing
            if (definition.classList.contains('bg-pink-300')) return;

            // If a word is selected (has green highlight), try to match it with the clicked definition
            if (selectedWord) {
                // Remove 'selected' class from the word
                selectedWord.classList.remove('bg-green-400', 'border-green-500');
                
                // Apply 'matched' styling to both word and definition
                selectedWord.classList.add('bg-pink-300', 'border-pink-400', 'cursor-default');
                definition.classList.add('bg-pink-300', 'border-pink-400', 'cursor-default');
                
                // Remove hover effects for matched items
                selectedWord.classList.remove('hover:bg-yellow-300');
                definition.classList.remove('hover:bg-blue-300');
                
                // Store the matched pair
                matchedPairs.set(selectedWord, definition);

                // --- Store the line coordinates for the matched pair ---
                const wordPoint = getElementLinePoint(selectedWord, true);
                const definitionPoint = getElementLinePoint(definition, false);
                matchLines.set(selectedWord, {
                    startX: wordPoint.x,
                    startY: wordPoint.y,
                    endX: definitionPoint.x,
                    endY: definitionPoint.y
                });
                
                selectedWord = null; // Clear selected word
                clearLine(); // Clear active line and redraw matched lines
            }
            checkCompletion(); // Check if submit button state needs to change
        }

        // Checks if all words have been matched and updates submit button state
        function checkCompletion() {
            const words = document.querySelectorAll('#wordColumn .word');
            const allWordsMatched = Array.from(words).every(word => word.classList.contains('bg-pink-300'));
            const submitButton = document.getElementById('submitButton');

            if (allWordsMatched) {
                submitButton.classList.remove('bg-gray-300', 'text-gray-700', 'cursor-not-allowed');
                submitButton.classList.add('bg-green-500', 'hover:bg-green-600', 'text-white', 'cursor-pointer');
                submitButton.disabled = false;
            } else {
                submitButton.classList.add('bg-gray-300', 'text-gray-700', 'cursor-not-allowed');
                submitButton.classList.remove('bg-green-500', 'hover:bg-green-600', 'text-white');
                submitButton.disabled = true;
            }
        }

        // Handles quiz submission
        function submitQuiz() {
            if (!quizActive) return;

            const studentName = document.getElementById('studentName').value.trim();
            if (!studentName) {
                showMessage('Missing Information', 'Please enter your name before submitting the quiz.');
                return;
            }

            // Stop the timer
            clearInterval(timerInterval);
            startTime = null;
            quizActive = false;
            
            // Clear the canvas completely after submission
            ctx.clearRect(0, 0, canvas.width, canvas.height); 

            const endTime = new Date();
            const timeDiff = (endTime - startTime) / 1000; // Time in seconds
            const minutes = Math.floor(timeDiff / 60);
            const seconds = Math.floor(timeDiff % 60);

            let correctCount = 0;
            let errors = [];
            let totalWordsInQuiz = 0; 

            document.querySelectorAll('#wordColumn .word').forEach(wordElement => {
                totalWordsInQuiz++;
                // Check if this word was matched and if the match is correct
                if (matchedPairs.has(wordElement)) {
                    const matchedDefinitionElement = matchedPairs.get(wordElement);
                    if (matchedDefinitionElement.textContent === wordElement.dataset.definition) {
                        correctCount++;
                        // Highlight correct matches in a final green color on the screen
                        wordElement.classList.remove('bg-pink-300', 'border-pink-400');
                        wordElement.classList.add('bg-green-200', 'border-green-400');
                        matchedDefinitionElement.classList.remove('bg-pink-300', 'border-pink-400');
                        matchedDefinitionElement.classList.add('bg-green-200', 'border-green-400');
                    } else {
                        errors.push(`Incorrect: "${wordElement.textContent}" was matched with "${matchedDefinitionElement.textContent}"`);
                        // Highlight incorrect matches in a final red color
                        wordElement.classList.remove('bg-pink-300', 'border-pink-400');
                        wordElement.classList.add('bg-red-200', 'border-red-400');
                        matchedDefinitionElement.classList.remove('bg-pink-300', 'border-pink-400');
                        matchedDefinitionElement.classList.add('bg-red-200', 'border-red-400');
                    }
                } else {
                    errors.push(`Unmatched: "${wordElement.textContent}"`);
                }
            });

            // Recalculate and redraw the lines with the final color coding
            matchLines.clear();
            document.querySelectorAll('#wordColumn .word').forEach(wordElement => {
                if (matchedPairs.has(wordElement)) {
                    const matchedDefinitionElement = matchedPairs.get(wordElement);
                    const wordPoint = getElementLinePoint(wordElement, true);
                    const definitionPoint = getElementLinePoint(matchedDefinitionElement, false);
                    matchLines.set(wordElement, {
                        startX: wordPoint.x,
                        startY: wordPoint.y,
                        endX: definitionPoint.x,
                        endY: definitionPoint.y
                    });
                }
            });
            drawMatchedLines();


            const accuracy = (correctCount / totalWordsInQuiz) * 100;

            const pageTitle = document.title;
            const submitTime = endTime.toLocaleString();
            
            // Construct the result message for the modal
            let resultMessage = `
                Page Title: ${pageTitle}
                Submission Time: ${submitTime}
                Student Name: ${studentName}
                Completion Time: ${minutes}m ${seconds}s
                Correct Matches: ${correctCount}/${totalWordsInQuiz}
                Accuracy: ${accuracy.toFixed(2)}%
            `;

            if (errors.length > 0) {
                resultMessage += `\n\nErrors:\n${errors.join('\n')}`;
            } else {
                resultMessage += `\n\nErrors: None 🎉`;
            }

            showMessage('Quiz Results', resultMessage);
        }

        // Starts the countdown timer
        function startTimer() {
            clearInterval(timerInterval); // Clear any existing timer
            remainingTime = totalTime; // Reset time
            updateTimerDisplay(); // Initial display
            startTime = new Date(); // Reset start time when timer starts
            
            timerInterval = setInterval(() => {
                remainingTime--;
                updateTimerDisplay();

                if (remainingTime <= 0) {
                    clearInterval(timerInterval);
                    showMessage('Time\'s Up!', 'Your time has run out. The quiz has been automatically submitted.');
                    // Must call setTimeout to allow the current function to finish before submission logic runs
                    setTimeout(submitQuiz, 10); 
                }
            }, 1000);
        }

        // Updates the timer display
        function updateTimerDisplay() {
            const minutes = Math.floor(remainingTime / 60);
            const seconds = remainingTime % 60;
            const timerElement = document.getElementById('timer');
            timerElement.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            
            // Change color when time is low
            if (remainingTime <= 30) {
                timerElement.classList.remove('text-blue-600');
                timerElement.classList.add('text-red-600');
            } else {
                timerElement.classList.remove('text-red-600');
                timerElement.classList.add('text-blue-600');
            }
        }

        // Shuffles an array (Fisher-Yates algorithm)
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]]; // Swap elements
            }
            return array;
        }

        // Displays a custom modal message
        function showMessage(title, message) {
            document.getElementById('modalTitle').textContent = title;
            document.getElementById('modalMessage').textContent = message;
            
            const modalContentDiv = document.getElementById('customModal').querySelector('.modal-content');
            
            // Remove all buttons except for the default 'Close' button functionality
            Array.from(modalContentDiv.querySelectorAll('button')).forEach(button => {
                if (!button.onclick.toString().includes('closeModal()')) {
                     button.remove();
                }
            });
            
            // Ensure a single 'Close' button is present and visible
            let closeButton = modalContentDiv.querySelector('button[onclick="closeModal()"]');
            if (!closeButton) {
                closeButton = document.createElement('button');
                closeButton.textContent = 'Close';
                closeButton.className = 'px-6 py-3 bg-blue-500 text-white font-semibold rounded-lg shadow-md transition-all duration-300 ease-in-out hover:bg-blue-600 focus:outline-none focus:ring-4 focus:ring-blue-300 text-lg';
                closeButton.onclick = closeModal;
                modalContentDiv.appendChild(closeButton);
            }
            closeButton.style.display = 'inline-block';

            document.getElementById('customModal').classList.remove('hidden'); // Show the modal
        }

        // Closes the custom modal message
        function closeModal() {
            document.getElementById('customModal').classList.add('hidden'); // Hide the modal
        }

        // Resets the quiz to its initial state
        function resetQuiz() {
            // Modify modal to include confirmation buttons for reset
            const modalMessageDiv = document.getElementById('modalMessage');
            modalMessageDiv.innerHTML = '<p class="text-base text-gray-700 leading-relaxed mb-6 whitespace-pre-line text-left">' + 
                                     'Are you sure you want to reset the quiz? Your current progress will be lost.' +
                                     '</p>';
            const modalContentDiv = document.getElementById('customModal').querySelector('.modal-content');
            
            // Remove existing buttons
            Array.from(modalContentDiv.querySelectorAll('button')).forEach(button => button.remove());

            // Add confirm and cancel buttons for the reset action
            const confirmButton = document.createElement('button');
            confirmButton.textContent = 'Yes, Reset';
            confirmButton.className = 'px-6 py-3 bg-red-500 text-white font-semibold rounded-lg shadow-md transition-all duration-300 ease-in-out hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-300 text-lg mr-2';
            confirmButton.onclick = () => {
                clearInterval(timerInterval);
                initQuiz(); // Re-initialize everything
                closeModal();
            };

            const cancelButton = document.createElement('button');
            cancelButton.textContent = 'Cancel';
            cancelButton.className = 'px-6 py-3 bg-gray-300 text-gray-700 font-semibold rounded-lg shadow-md transition-all duration-300 ease-in-out hover:bg-gray-400 focus:outline-none focus:ring-4 focus:ring-gray-200 text-lg';
            cancelButton.onclick = closeModal;

            modalContentDiv.appendChild(confirmButton);
            modalContentDiv.appendChild(cancelButton);
            document.getElementById('modalTitle').textContent = 'Confirm Reset';
            document.getElementById('customModal').classList.remove('hidden');
        }

        // Add event listener for window resize to keep the canvas aligned
        window.addEventListener('resize', () => {
            // Resize canvas on window resize and redraw all lines
            resizeCanvas(); 
            clearLine(); 
        });

        // Initialize quiz when the window loads
        window.onload = initQuiz;
    </script>
</body>
</html>
